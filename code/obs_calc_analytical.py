import numpy as np
from scipy.integrate import quad
from scipy.integrate import dblquad
from scipy import special


# HERE we gather functions that output analytical results which can be used to
# compare against FH results


# current
def I_Knight_calc(params):
    """Calculates the approximate impedance and current phasor for a round
        wire of length L following Knights approximation formula
        details of the formula are in the summary
        """
    ro_t, ri_t, flen, node_dens, sigma, mu_0, mu_r, freq = params
    mu = mu_0 * mu_r
    if sigma > 0:
        delta = np.sqrt(1 / (sigma * np.pi * freq * mu))  # skin depth
        delta_p = delta * (1.0 - np.exp(- ro_t / delta))
        Z = 0.62006 * ro_t / delta
        y = 0.189774 / ((1 + 0.272481 * (Z ** 1.82938 - Z ** (-0.99457)) ** 2) ** 1.0941)
        Aeff = np.pi * (2.0 * ro_t * delta_p - delta_p ** 2) * (1 + y)
        R_AC = 1.0 / (sigma * Aeff)  # resistance per unit length

        Z2 = (0.27445 / np.sqrt(2)) / (2 * ro_t / delta)
        y2 = 0.02369 / (1.0 + 0.284 * (Z2 ** 1.4754 - Z2 ** (-2.793)) ** 2) ** 0.8955
        Li = mu / (2 * np.pi) * delta * (1 - np.exp(-2 * ro_t / (4 * delta)) ** 3.74) ** (1 / 3.74) * 1 / (
                2 * ro_t * (1 - y2))

        Le = mu / (2 * np.pi) * (np.log(2 * flen / ro_t) - 1)

        XL = 2 * np.pi * freq * (Li + Le)  # inductance per unit length
        # Z_wire = flen * (R_AC + 1.0j * XL)  # impedance of the wire
        # Z_wire_2 = flen * (R_AC + 2.0j * np.pi * freq * Li)
        I_Knight = 1 / (flen * np.sqrt(R_AC ** 2 + XL ** 2))
    else:
        I_Knight = 0
    return I_Knight


def I_Bessel_calc(params):
    """This is the "correct" analytical expression for current through a wire
    except the Le part wich is an approximation (See the summary)
    It uses Bessel functions which runs into problems at high frequencies.
    When this happens use Knight approximate Formula.
    """
    ro_t, ri_t, flen, node_dens, sigma, mu_0, mu_r, freq = params
    mu = mu_0 * mu_r
    om = 2 * np.pi * freq
    delta = np.sqrt(2 / (sigma * om * mu))  # skin depth
    k = (1 - 1.0j) / delta
    bessel0k_ro = special.jv(0, k * ro_t)
    bessel1k_ro = special.jv(1, k * ro_t)

    # Wikipedia impedance
    z_w = k * flen / (sigma * 2 * np.pi * ro_t) * (bessel0k_ro / bessel1k_ro)
    Le = mu / (2 * np.pi) * (np.log(2 * flen / ro_t) - 1)
    z_w2 = z_w + 1.0j * om * flen * Le
    i_bessel = 1 / np.sqrt(z_w2.real ** 2 + z_w2.imag ** 2)

    return i_bessel


# field
def BC_wire_DC(rc, zc, R, L):
    """Formula from paper Ferreira 2018:
       "Magnetic field generated by the flow of DC current through finite
       length nonmagnetic conductors (cylinders, tubes, coaxial cables)"
       Calculates the B field of DC current density J0
       for a wire segment of Radius R and length L. 
       The wire axis is along z and the wire is centered around z=0. The 
       B field is calculated at position z = zC and radial distance from
       wire axis rc > R
    """

    if zc < 0:  # formulas are only for zC>0
        zc = abs(zc)  # but field is symmetric around
        # z=0 so no problem

    def h_pm(zc, L):
        hp = np.sqrt((L / 2 + zc) ** 2)
        hm = np.sqrt((L / 2 - zc) ** 2)
        return hp, hm

    def sigma_p_ker(r, theta, rc, zc, R, L):
        hp, hm = h_pm(zc, L)
        sigma_p_ker = 1 / np.pi * hp / (np.sqrt(hp ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hp ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hp ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_p_ker

    def sigma_m_ker(r, theta, rc, zc, R, L):
        hp, hm = h_pm(zc, L)
        sigma_m_ker = 1 / np.pi * hm / (np.sqrt(hm ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hm ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hm ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_m_ker

    def bs_ker1(r, theta, rc, zc, R, L):
        return 1 / rc * (sigma_p_ker(r, theta, rc, zc, R, L) - sigma_m_ker(r, theta, rc, zc, R, L)) * r

    def bs_ker2(r, theta, rc, zc, R, L):
        return 1 / rc * (sigma_p_ker(r, theta, rc, zc, R, L) + sigma_m_ker(r, theta, rc, zc, R, L)) * r

    if zc > L / 2:
        bc = bs_ker1

    else:
        bc = bs_ker2

    bs, bs_err = dblquad(bc, 0, np.pi,
                         lambda theta: 0,
                         lambda theta: R, args=(rc, zc, R, L))

    if L / 2 >= zc >= 0 and rc < R:
        bs = bs - 2 * (R ** 2 - rc ** 2) / (rc * 2)

    return bs, bs_err


def BC_wire_AC(rc, zc, R, L, params):
    """Formula from paper Ferreira 2018:
       "Magnetic field generated by the flow of AC current through finite
       length nonmagnetic conductors (cylinders, tubes, coaxial cables)"
       Calculates the B field of DC current density J0
       for a wire segment of Radius R and length L. 
       The wire axis is along z and the wire is centered around z=0. The 
       B field is calculated at position z = zC and radial distance from
       wire axis rc > R
    """
    ro_t, ri_t, flen, node_dens, sigma, mu_0, mu_r, freq = params  # unpack params

    delta = np.sqrt(2 / (2 * np.pi * freq * sigma * mu_0))

    def h_pm(zc, L):
        hp = np.sqrt((L / 2 + zc) ** 2)
        hm = np.sqrt((L / 2 - zc) ** 2)
        return hp, hm

    def sigma_p_ker(r, theta, rc, zc, R, L):
        hp, hm = h_pm(zc, L)
        sigma_p_ker = 1 / np.pi * \
                      hp / (np.sqrt(hp ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hp ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hp ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_p_ker

    def sigma_m_ker(r, theta, rc, zc, R, L):
        hp, hm = h_pm(zc, L)
        sigma_m_ker = 1 / np.pi * \
                      hm / (np.sqrt(hm ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hm ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hm ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_m_ker

    def bs_ker1(r, theta, rc, zc, R, L, delta):
        return (1 / rc * (sigma_p_ker(r, theta, rc, zc, R, L)
                          - sigma_m_ker(r, theta, rc, zc, R, L)) * r * np.exp(-(1.0j + 1) * (R - r) / delta)).real

    def bs_ker2(r, theta, rc, zc, R, L, delta):
        return (1 / rc * (sigma_p_ker(r, theta, rc, zc, R, L)
                          + sigma_m_ker(r, theta, rc, zc, R, L)) * r * np.exp(-(1.0j + 1) * (R - r) / delta)).real

    def bs_ker3(r, theta, rc, zc, R, L, delta):
        return (1 / rc * (-2) * r * np.exp(-(1.0j + 1) * (R - r) / delta)).real

    if zc > L / 2:
        bc = bs_ker1

    else:
        bc = bs_ker2

    bs, bs_err = dblquad(bc, 0, np.pi,
                         lambda theta: 0,
                         lambda theta: R, args=(rc, zc, R, L, delta))

    if zc <= L / 2 and zc >= 0 and rc < R:
        bc = bs_ker3
        bs = bs + quad(bc, rc, R, args=(rc, zc, R, L, delta))[0]

    return bs, bs_err


# these functions are used to check Ferreira formulas in the 2016 paper
# they don't reflect any observables
def sigma_ker(theta, rc, H, R):
    sigma_H_ker = 1 / np.pi * \
                  H / (np.sqrt(H ** 2 + R ** 2 + rc ** 2 + 2 * R * rc * np.cos(theta))) * \
                  (H ** 2 + R ** 2 + R * rc * np.cos(theta)) / \
                  (H ** 2 + R ** 2 * np.sin(theta) ** 2)

    return sigma_H_ker


def om_func(rc, H, R):
    """Formula from paper Ferreira 2016:
    "Magnetic field created by a conducting cylindrical shell of finite
    length"
    """
    sigma_int = quad(sigma_ker, 0, np.pi, args=(rc, H, R))
    om, om_err = 2 * np.pi * (1 - sigma_int[0]), sigma_int[1]
    return om, om_err


def BC_wire(rc, zc, R, L):
    """Formula from paper Ferreira 2018:
       "Magnetic field generated by the flow of AC current through finite
       length nonmagnetic conductors (cylinders, tubes, coaxial cables)"
       Calculates the B field of DC current density J0
       for a wire segment of Radius R and length L. 
       The wire axis is along z and the wire is centered around z=0. The 
       B field is calculated at position z = zC and radial distance from
       wire axis rc > R
    """

    def h_pm(zc, L):
        hp = np.sqrt((L / 2 + zc) ** 2)
        hm = np.sqrt((L / 2 - zc) ** 2)
        return hp, hm

    def sigma_p_ker(r, theta, rc, zc, R, L):
        hp, hm = h_pm(zc, L)
        sigma_p_ker = 1 / np.pi * \
                      hp / (np.sqrt(hp ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hp ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hp ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_p_ker

    def sigma_m_ker(r, theta, rc, zC, R, L):
        hp, hm = h_pm(zC, L)
        sigma_m_ker = 1 / np.pi * \
                      hm / (np.sqrt(hm ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hm ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hm ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_m_ker

    def bs_ker1(r, theta, rc, zC, R, L):
        return 1 / rc * (sigma_p_ker(r, theta, rc, zC, R, L) - sigma_m_ker(r, theta, rc, zC, R, L)) * r

    def bs_ker2(r, theta, rc, zc, R, L):
        return 1 / rc * (sigma_p_ker(r, theta, rc, zc, R, L) + sigma_m_ker(r, theta, rc, zc, R, L)) * r

    if zc > L / 2:
        bc = bs_ker1

    else:
        bc = bs_ker2

    bs, bs_err = dblquad(bc, 0, np.pi,
                         lambda theta: 0,
                         lambda theta: R, args=(rc, zc, R, L))

    if L / 2 >= zc >= 0 and rc < R:
        bs = bs - 2 * (R ** 2 - rc ** 2) / (rc * 2)

    return bs, bs_err


def BC_wire_AC(rc, zc, R, L, params):
    """Formula from paper Ferreira 2018:
       "Magnetic field generated by the flow of AC current through finite
       length nonmagnetic conductors (cylinders, tubes, coaxial cables)"
       Calculates the B field of DC current density J0
       for a wire segment of Radius R and length L. 
       The wire axis is along z and the wire is centered around z=0. The 
       B field is calculated at position z = z_c and radial distance from
       wire axis rc > R
    """

    ro_t, ri_t, flen, node_dens, sigma, mu_0, mu_r, freq = params  # unpack params

    delta = np.sqrt(2 / (2 * np.pi * freq * sigma * mu_0))

    def h_pm(zc, L):
        hp = np.sqrt((L / 2 + zc) ** 2)
        hm = np.sqrt((L / 2 - zc) ** 2)
        return hp, hm

    def sigma_p_ker(r, theta, rc, zc, R, L):
        hp, hm = h_pm(zc, L)
        sigma_p_ker = 1 / np.pi * \
                      hp / (np.sqrt(hp ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hp ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hp ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_p_ker

    def sigma_m_ker(r, theta, rc, zc, R, L):
        hp, hm = h_pm(zc, L)
        sigma_m_ker = 1 / np.pi * \
                      hm / (np.sqrt(hm ** 2 + r ** 2 + rc ** 2 + 2 * r * rc * np.cos(theta))) * \
                      (hm ** 2 + r ** 2 + r * rc * np.cos(theta)) / \
                      (hm ** 2 + r ** 2 * np.sin(theta) ** 2)

        return sigma_m_ker

    def BS_ker1(r, theta, rc, zc, R, L, delta):
        return (1 / rc * (sigma_p_ker(r, theta, rc, zc, R, L)
                          - sigma_m_ker(r, theta, rc, zc, R, L)) * r ** np.cos((R - r) / delta) * np.exp(
            -(R - r) / delta))

    def BS_ker2(r, theta, rc, zc, R, L, delta):
        return (1 / rc * (sigma_p_ker(r, theta, rc, zc, R, L)
                          + sigma_m_ker(r, theta, rc, zc, R, L)) * r ** np.cos((R - r) / delta) * np.exp(
            -(R - r) / delta))

    def BS_ker3(r, theta, rc, zc, R, L, delta):

        func = \
            1 / rc * (-2) * r * np.cos((R - r) / delta) * np.exp(-(R - r) / delta)

    def BS_ker3_im(r, theta, rc, zc, R, L, delta):

        func = \
            1 / rc * (-2) * r * np.sin((R - r) / delta) * np.exp(-(R - r) / delta)

        return func
        # return (1/rc*(-2)*r*np.exp(-(1.0j+1)(R-r)/(delta))).real
        # return (1/rc*(-2)*r*np.exp(-(1.0j+1)(R-r)/(delta))).real

    if zc > L / 2:
        bc = BS_ker1

    else:
        bc = BS_ker2

    bs, bs_err = dblquad(bc, 0, np.pi,
                         lambda theta: 0,
                         lambda theta: R, args=(rc, zc, R, L, delta))

    if L / 2 >= zc >= 0 and rc < R:
        bc_re = BS_ker3
        bc_im = BS_ker3_im
        bs_re, bs_err_re = dblquad(bc_re, 0, np.pi,
                                   lambda theta: 0,
                                   lambda theta: R, args=(rc, zc, R, L, delta))
        bs_im, bs_err_im = dblquad(bc_im, 0, np.pi,
                                   lambda theta: 0,
                                   lambda theta: R, args=(rc, zc, R, L, delta))

        bs = np.sqrt(bs_re ** 2 + bs_im ** 2)
        bs_err = bs_err_re
        # bs=bs+quad(BC, rc, R, args=(rc, z_c, R, L, delta))[0]
    # print("delta")
    # print("delta")
    # print("delta")
    # print("delta")
    # print(delta)
    # exit()

    return bs, bs_err
